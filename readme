# Server Health Check Web Application

A web-based interface for running server health checks on multiple remote servers via SSH. Upload a list of server IPs/hostnames, and get comprehensive health reports including uptime, disk usage, memory utilization, and security audit information.

## Features

- üåê **Web Interface**: User-friendly web UI for uploading server lists
- üìä **Comprehensive Checks**: System uptime, disk usage, memory stats, and SSH security audit
- üì• **File Upload**: Simple drag-and-drop or browse file upload
- üìÑ **Downloadable Reports**: Get detailed text reports of all health checks
- üîí **Secure**: Multiple security layers protect your data (see [SECURITY.md](SECURITY.md))
- üõ°Ô∏è **Privacy First**: No IP logging, session-based identification, sanitized outputs
- ‚ö° **Rate Limited**: Protection against abuse with request limiting
- üîê **Input Validation**: Comprehensive validation prevents injection attacks

## Quick Start

### Option 1: Local Development

1. **Install Dependencies**
```bash
# Create virtual environment
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install requirements
pip install -r requirements.txt
```

2. **Run the Application**
```bash
python app.py
```

3. **Access the Application**
Open your browser and navigate to: `http://localhost:5000`

### Option 2: Production Deployment (Ubuntu/Debian)

1. **Install System Dependencies**
```bash
sudo apt update
sudo apt install python3 python3-venv python3-pip nginx
```

2. **Setup Application**
```bash
# Create application directory
sudo mkdir -p /opt/health-check
sudo chown $USER:$USER /opt/health-check

# Copy files to deployment directory
cp -r * /opt/health-check/
cd /opt/health-check

# Create virtual environment
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
pip install gunicorn
```

3. **Setup Systemd Service**
```bash
# Copy service file
sudo cp health-check.service /etc/systemd/system/

# Edit service file to match your setup
sudo nano /etc/systemd/system/health-check.service

# Enable and start service
sudo systemctl daemon-reload
sudo systemctl enable health-check
sudo systemctl start health-check

# Check status
sudo systemctl status health-check
```

4. **Setup Nginx Reverse Proxy**
```bash
# Copy nginx configuration
sudo cp nginx.conf /etc/nginx/sites-available/health-check

# Update domain name in config
sudo nano /etc/nginx/sites-available/health-check

# Enable site
sudo ln -s /etc/nginx/sites-available/health-check /etc/nginx/sites-enabled/

# Test nginx configuration
sudo nginx -t

# Restart nginx
sudo systemctl restart nginx
```

5. **(Optional) Setup SSL with Let's Encrypt**
```bash
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d your-domain.com
```

## Usage

### 1. Prepare Your Server List

Create a text file (e.g., `servers.txt`) with one server per line:

```
server1.example.com
192.168.1.10
192.168.1.20
server2.example.com
# Comments are ignored
```

### 2. Upload and Run

1. Open the web interface in your browser
2. Enter the SSH username (e.g., `admin` or `root`)
3. Upload your server list file
4. Click "Run Health Check"
5. Wait for results (may take a few minutes for multiple servers)
6. Download the detailed report

### 3. Review Results

The application will display:
- System uptime for each server
- Disk usage statistics
- Memory utilization
- Failed SSH login attempts (security audit)

## SSH Setup

The application requires SSH access to your servers. Ensure:

1. **SSH Keys are Configured**
```bash
# Generate SSH key if you don't have one
ssh-keygen -t rsa -b 4096

# Copy key to servers
ssh-copy-id username@server-hostname
```

2. **Test SSH Access**
```bash
# Verify you can connect without password
ssh username@server-hostname
```

## API Endpoints

- `GET /` - Main web interface
- `POST /api/upload` - Upload server list and run health check
- `GET /api/download/<job_id>` - Download results for a specific job
- `GET /health` - Application health check endpoint

## Configuration

### Environment Variables

You can configure the application using environment variables:

- `FLASK_ENV`: Set to `production` for production deployment
- `MAX_CONTENT_LENGTH`: Maximum upload file size (default: 1MB)

### File Locations

- `uploads/` - Temporary storage for uploaded server lists
- `results/` - Stored health check results
- Logs are created in `/tmp/server_health.XXXXXX` during script execution

## Security Considerations

**üîí This application implements comprehensive security measures:**

- ‚úÖ **No IP Logging**: Anonymous session-based identification
- ‚úÖ **Output Sanitization**: Removes sensitive data from results
- ‚úÖ **Input Validation**: Prevents injection attacks
- ‚úÖ **Rate Limiting**: Protects against abuse
- ‚úÖ **Security Headers**: XSS, clickjacking, and MIME-sniffing protection
- ‚úÖ **Session Security**: Secure, HttpOnly cookies
- ‚úÖ **File Validation**: Strict validation of uploads
- ‚úÖ **Access Control**: Users can only download their own results
- ‚úÖ **Automatic Cleanup**: Files deleted after 24 hours

**For detailed security information, see [SECURITY.md](SECURITY.md)**

### Production Security Checklist

Before deploying to production:

1. **Set Secure Secret Key**:
```bash
export SECRET_KEY=$(python3 -c "import secrets; print(secrets.token_hex(32))")
```

2. **Enable HTTPS** (required for secure cookies):
```bash
sudo certbot --nginx -d yourdomain.com
```

3. **Configure Firewall**:
```bash
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS
sudo ufw enable
```

4. **Review Security Settings**: Check [SECURITY.md](SECURITY.md) for complete guide

5. **Run Security Tests**:
```bash
python3 test_security.py
```

### What Data is Protected

**We DO NOT collect or store**:
- User IP addresses
- Server hostnames/IPs (after job completion)
- SSH credentials or keys
- Personal information
- Long-term logs

All data is session-based and automatically deleted after 24 hours.

## Troubleshooting

### SSH Connection Failures
- Verify SSH keys are properly configured
- Check network connectivity to target servers
- Ensure the SSH username is correct
- Verify firewall rules allow SSH (port 22)

### Application Won't Start
```bash
# Check logs
sudo journalctl -u health-check -f

# Or check application logs directly
tail -f /tmp/server_health.*
```

### Permission Issues
```bash
# Ensure script is executable
chmod +x server_health_check.sh

# Check file ownership
ls -la
```

## Development

### Project Structure
```
Health_Check/
‚îú‚îÄ‚îÄ app.py                      # Flask application
‚îú‚îÄ‚îÄ server_health_check.sh      # Health check script
‚îú‚îÄ‚îÄ requirements.txt            # Python dependencies
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ index.html             # Web interface
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îú‚îÄ‚îÄ style.css              # Styles
‚îÇ   ‚îî‚îÄ‚îÄ script.js              # Frontend JavaScript
‚îú‚îÄ‚îÄ uploads/                    # Uploaded files (created automatically)
‚îú‚îÄ‚îÄ results/                    # Result files (created automatically)
‚îú‚îÄ‚îÄ Procfile                    # Render process definition
‚îú‚îÄ‚îÄ build.sh                    # Build automation script
‚îî‚îÄ‚îÄ render.yaml                 # Render deployment config
```

### Running Tests
```bash
# Create a test server list
echo "localhost" > test_servers.txt

# Test the script directly
./server_health_check.sh -f test_servers.txt -u $USER

# Test the web application
python app.py
# Then access http://localhost:5000
```

## Requirements

- Python 3.8+
- SSH client
- Bash
- Target servers must have:
  - SSH access enabled
  - Standard Unix utilities (df, free, uptime, awk)

## License

This project is open source and available for educational and commercial use.

## Contributing

Contributions are welcome! Please feel free to submit issues or pull requests.

## Support

For issues or questions:
1. Check the Troubleshooting section
2. Review the logs
3. Ensure all requirements are met
4. Test SSH connectivity manually

## Roadmap

Potential future enhancements:
- User authentication and authorization
- Database storage for historical results
- Scheduled health checks
- Email notifications
- Dashboard with charts and graphs
- Support for different monitoring metrics
- Multi-user support with role-based access
